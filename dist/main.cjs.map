{"version":3,"sources":["../../signals/src/main.ts","../src/main.ts"],"names":["currentEffect","signal","initialValue","value","subscribers","read","write","newValue","fn","update","peek","subscribe","sig","effect","cleanup","isDisposed","execute","prevEffect","result","disposer","computed","HttpClient","config","interceptor","index","mergedConfig","cacheKey","cached","url","request","fetchResponse","data","response","error","finalError","params","key","query","message","http","configureHttp","useQuery","queryKey","queryFn","options","v","isLoading","isError","b","isSuccess","enabled","fetchData","err","httpError","y","useMutation","mutationFn","variables","retry","retries","retryDelay","attempt","retryCondition","lastError","delay","resolve","createAbortController","timeout","controller","main_default"],"mappings":"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","file":"main.cjs","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\n// src/main.ts\r\n//\r\n// Made with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import { Signal, EffectCleanup, Computed } from './types';\r\n    export type * from './types';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\r\n\r\n    let currentEffect       : (() => void)   | null = null;\r\n    let currentRoot         : (() => void)[] | null = null;\r\n    let batchDepth          : number                = 0;\r\n    const batchedEffects    : Set<() => void>       = new Set<() => void>();\r\n    const flushedEffects    : Set<() => void>       = new Set<() => void>();\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Creates a reactive signal that can be read, written, and subscribed to.\r\n     * @template T - The type of value stored in the signal\r\n     * @param {T} initialValue - The initial value of the signal\r\n     * @returns {Signal<T>} A signal object with read, set, update, peek, and subscribe methods\r\n     * @example\r\n     * const count = signal(0);\r\n     * console.log(count()); // 0\r\n     * count.set(5); // Update value\r\n     */\r\n    export function signal<T>(initialValue: T): Signal<T> {\r\n        let value           = initialValue;\r\n        const subscribers   = new Set<() => void>();\r\n\r\n        function read(): T {\r\n            // Track dependency if inside effect\r\n            if (currentEffect) {\r\n                subscribers.add(currentEffect);\r\n            }\r\n            return value;\r\n        }\r\n\r\n        function write(newValue: T): void {\r\n            // Only update if value actually changed\r\n            if (Object.is(value, newValue)) return;\r\n\r\n            value = newValue;\r\n\r\n            // Notify all subscribers\r\n            if (batchDepth > 0) {\r\n                // Batch mode: collect effects\r\n                subscribers.forEach(fn => batchedEffects.add(fn));\r\n            } else {\r\n                // Immediate mode: run effects now\r\n                subscribers.forEach(fn => fn());\r\n            }\r\n        }\r\n\r\n        function update(fn: (prev: T) => T): void {\r\n            write(fn(value));\r\n        }\r\n\r\n        function peek(): T {\r\n            // Read without tracking\r\n            return value;\r\n        }\r\n\r\n        function subscribe(fn: () => void): () => void {\r\n            subscribers.add(fn);\r\n            return () => subscribers.delete(fn);\r\n        }\r\n\r\n        // Create signal function with methods\r\n        const sig = read as Signal<T>;\r\n        sig.set = write;\r\n        sig.update = update;\r\n        sig.peek = peek;\r\n        sig.subscribe = subscribe;\r\n\r\n        return sig;\r\n    }\r\n\r\n    /**\r\n     * Automatically runs a function when its signal dependencies change.\r\n     * @param {() => EffectCleanup} fn - The effect function to run. Can optionally return a cleanup function.\r\n     * @returns {() => void} A dispose function to stop the effect and clean up\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   console.log('Count:', count());\r\n     *   return () => console.log('Cleaning up');\r\n     * });\r\n     */\r\n    export function effect(fn: () => EffectCleanup): () => void {\r\n        let cleanup: (() => void) | undefined;\r\n        let isDisposed = false;\r\n\r\n        const execute = () => {\r\n            if (isDisposed) return;\r\n\r\n            // Run cleanup from previous execution\r\n            if (cleanup) {\r\n                cleanup();\r\n                cleanup = undefined;\r\n            }\r\n\r\n            // Set as current effect for dependency tracking\r\n            const prevEffect = currentEffect;\r\n            currentEffect = execute;\r\n\r\n            try {\r\n                // Run the effect function\r\n                const result = fn();\r\n\r\n                // Store cleanup if returned\r\n                if (typeof result === 'function') {\r\n                    cleanup = result;\r\n                }\r\n            } finally {\r\n                // Restore previous effect\r\n                currentEffect = prevEffect;\r\n            }\r\n        };\r\n\r\n        // Run immediately\r\n        execute();\r\n\r\n        // Create dispose function\r\n        const disposer = () => {\r\n            if (isDisposed) return;\r\n            isDisposed = true;\r\n            if (cleanup) cleanup();\r\n        };\r\n\r\n        // Register with current root if one exists\r\n        if (currentRoot) {\r\n            currentRoot.push(disposer);\r\n        }\r\n\r\n        // Return dispose function\r\n        return disposer;\r\n    }\r\n\r\n    /**\r\n     * Creates a computed signal that automatically updates when its dependencies change.\r\n     * The computation result is cached and only recomputed when dependencies change.\r\n     * @template T - The type of value computed\r\n     * @param {() => T} fn - The computation function\r\n     * @returns {Computed<T>} A read-only computed signal\r\n     * @example\r\n     * const count = signal(5);\r\n     * const doubled = computed(() => count() * 2);\r\n     * console.log(doubled()); // 10\r\n     */\r\n    export function computed<T>(fn: () => T): Computed<T> {\r\n        const sig = signal<T>(undefined as T);\r\n\r\n        // Create effect that updates the signal\r\n        effect(() => {\r\n            sig.set(fn());\r\n        });\r\n\r\n        // Mark as computed\r\n        const computed = sig as Computed<T>;\r\n        Object.defineProperty(computed, 'isComputed', {\r\n            value: true,\r\n            writable: false\r\n        });\r\n\r\n        return computed;\r\n    }\r\n\r\n    /**\r\n     * Groups multiple signal updates together, deferring effect execution until all updates complete.\r\n     * This improves performance by preventing cascading effect runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that performs multiple signal updates\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const a = signal(1);\r\n     * const b = signal(2);\r\n     * batch(() => {\r\n     *   a.set(10);\r\n     *   b.set(20);\r\n     * }); // Effects only run once\r\n     */\r\n    export function batch<T>(fn: () => T): T {\r\n        batchDepth++;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            batchDepth--;\r\n\r\n            // If we're back at depth 0, flush batched effects\r\n            if (batchDepth === 0) {\r\n                // Keep batch mode active while flushing to prevent cascading effects\r\n                batchDepth++;\r\n                flushedEffects.clear();\r\n                try {\r\n                    // Keep running effects until no more are queued\r\n                    while (batchedEffects.size > 0) {\r\n                        const effects = Array.from(batchedEffects);\r\n                        batchedEffects.clear();\r\n                        effects.forEach(fn => {\r\n                            // Only run if we haven't run it in this batch\r\n                            if (!flushedEffects.has(fn)) {\r\n                                flushedEffects.add(fn);\r\n                                fn();\r\n                            }\r\n                        });\r\n                    }\r\n                } finally {\r\n                    batchDepth--;\r\n                    flushedEffects.clear();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads signals without creating dependencies on them.\r\n     * Useful for accessing signal values without triggering effect re-runs.\r\n     * @template T - The return type of the function\r\n     * @param {() => T} fn - A function that accesses signals\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const count = signal(0);\r\n     * effect(() => {\r\n     *   const value = untrack(() => count()); // Won't trigger re-run\r\n     *   console.log(value);\r\n     * });\r\n     */\r\n    export function untrack<T>(fn: () => T): T {\r\n        const prevEffect = currentEffect;\r\n        currentEffect = null;\r\n\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            currentEffect = prevEffect;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an effect only when a specific signal changes, providing both new and previous values.\r\n     * @template T - The type of the signal\r\n     * @param {Signal<T>} sig - The signal to watch\r\n     * @param {(value: T, prevValue: T) => EffectCleanup} fn - Effect function called with new and previous values\r\n     * @returns {() => void} A dispose function to stop watching\r\n     * @example\r\n     * const count = signal(0);\r\n     * on(count, (newVal, oldVal) => {\r\n     *   console.log(`Changed from ${oldVal} to ${newVal}`);\r\n     * });\r\n     */\r\n    export function on<T>(\r\n        sig: Signal<T>,\r\n        fn: (value: T, prevValue: T) => EffectCleanup\r\n    ): () => void {\r\n        let prevValue = sig.peek();\r\n\r\n        return effect(() => {\r\n            // Read the signal to create dependency\r\n            const value = sig();\r\n\r\n            // Run callback without tracking new dependencies\r\n            const cleanup = untrack(() => fn(value, prevValue));\r\n            prevValue = value;\r\n            return cleanup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a store object where each property is a signal.\r\n     * Provides a convenient way to manage multiple related reactive values.\r\n     * @template T - The type of the initial state object\r\n     * @param {T} initialState - An object with initial values\r\n     * @returns {{ [K in keyof T]: Signal<T[K]> }} An object with signals for each property\r\n     * @example\r\n     * const state = store({ count: 0, name: 'John' });\r\n     * console.log(state.count()); // 0\r\n     * state.name.set('Jane');\r\n     */\r\n    export function store<T extends Record<string, any>>(\r\n        initialState: T\r\n    ): { [K in keyof T]: Signal<T[K]> } {\r\n        const store = {} as any;\r\n\r\n        for (const key in initialState) {\r\n            store[key] = signal(initialState[key]);\r\n        }\r\n\r\n        return store;\r\n    }\r\n\r\n    /**\r\n     * Memoizes the result of an expensive computation, caching it indefinitely.\r\n     * Unlike computed, this doesn't depend on reactive signals.\r\n     * @template T - The type of the memoized value\r\n     * @param {() => T} fn - A function that performs the computation\r\n     * @returns {() => T} A function that returns the cached result\r\n     * @example\r\n     * const expensiveCalc = memo(() => {\r\n     *   return Array.from({ length: 1000 }).map(expensiveOp);\r\n     * });\r\n     * const result = expensiveCalc(); // Computed only once\r\n     */\r\n    export function memo<T>(fn: () => T): () => T {\r\n        let cachedValue: T | undefined;\r\n        let hasCachedValue = false;\r\n\r\n        return () => {\r\n            if (hasCachedValue) {\r\n                return cachedValue as T;\r\n            }\r\n\r\n            // Compute the value\r\n            const value = fn();\r\n\r\n            // Cache it\r\n            cachedValue = value;\r\n            hasCachedValue = true;\r\n\r\n            return value;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a root scope for managing effect and computed signal lifecycles.\r\n     * All effects and disposers created within the function are collected and can be cleaned up together.\r\n     * @template T - The return type of the function\r\n     * @param {(dispose: () => void) => T} fn - A function that receives a dispose function\r\n     * @returns {T} The return value of the function\r\n     * @example\r\n     * const dispose = root((dispose) => {\r\n     *   effect(() => console.log('Running'));\r\n     *   return 42;\r\n     * });\r\n     * dispose(); // Cleans up all effects created in the root\r\n     */\r\n    export function root<T>(fn: (dispose: () => void) => T): T {\r\n        const disposers: (() => void)[] = [];\r\n        const prevRoot = currentRoot;\r\n        currentRoot = disposers;\r\n\r\n        try {\r\n            const dispose = () => {\r\n                disposers.forEach(d => d());\r\n                disposers.length = 0;\r\n                currentRoot = prevRoot;\r\n            };\r\n\r\n            return fn(dispose);\r\n        } finally {\r\n            currentRoot = prevRoot;\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\r\n\r\n    /**\r\n     * Development utilities for debugging signal reactivity\r\n     */\r\n    export const dev = {\r\n        /**\r\n         * Returns the currently executing effect, or null if no effect is running\r\n         * @returns {(() => void) | null} The current effect function or null\r\n         */\r\n        getCurrentEffect(): (() => void) | null {\r\n            return currentEffect;\r\n        },\r\n\r\n        /**\r\n         * Returns the current batch depth (for debugging nested batch calls)\r\n         * @returns {number} The current batch nesting level\r\n         */\r\n        getBatchDepth(): number {\r\n            return batchDepth;\r\n        },\r\n\r\n        /**\r\n         * Returns the count of effects currently pending in the batch queue\r\n         * @returns {number} The number of batched effects waiting to run\r\n         */\r\n        getBatchedEffectsCount(): number {\r\n            return batchedEffects.size;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Type guard to check if a value is a signal\r\n     * @template T - The type of value the signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a signal\r\n     * @example\r\n     * if (isSignal(myValue)) {\r\n     *   console.log(myValue());\r\n     * }\r\n     */\r\n    export function isSignal<T>(value: any): value is Signal<T> {\r\n        return (\r\n            typeof value === 'function' &&\r\n            'set' in value &&\r\n            'update' in value &&\r\n            'peek' in value\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Type guard to check if a value is a computed signal\r\n     * @template T - The type of value the computed signal contains\r\n     * @param {any} value - The value to check\r\n     * @returns {boolean} True if the value is a computed signal\r\n     * @example\r\n     * if (isComputed(myValue)) {\r\n     *   console.log('This is a computed signal');\r\n     * }\r\n     */\r\n    export function isComputed<T>(value: any): value is Computed<T> {\r\n        return isSignal(value) && 'isComputed' in value;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ ════ ════════════════════════════════════════╗\r\n\r\n    export default {\r\n        signal,\r\n        effect,\r\n        computed,\r\n        batch,\r\n        untrack,\r\n        on,\r\n        store,\r\n        memo,\r\n        root,\r\n        isSignal,\r\n        isComputed,\r\n        dev\r\n    };\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\n// src/main.ts\r\n//\r\n// Made with ❤️ by Maysara.\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\r\n\r\n    import { signal, computed, effect } from '@minejs/signals';\r\n    import * as types from './types';\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export class HttpClient {\r\n        private config                  : Partial<types.RequestConfig>              = {};\r\n        private requestInterceptors     : types.Interceptor<types.RequestConfig>[]  = [];\r\n        private responseInterceptors    : types.Interceptor<types.Response<any>>[]  = [];\r\n        private cache                   = new Map<string, { data: types.Response<any>; timestamp: number }>();\r\n\r\n        constructor(config: Partial<types.RequestConfig> = {}) {\r\n            this.config = config;\r\n        }\r\n\r\n        /**\r\n         * Set default config\r\n         */\r\n        public setConfig(config: Partial<types.RequestConfig>): void {\r\n            this.config = { ...this.config, ...config };\r\n        }\r\n\r\n        /**\r\n         * Add request interceptor\r\n         */\r\n        public interceptRequest(interceptor: types.Interceptor<types.RequestConfig>): () => void {\r\n            this.requestInterceptors.push(interceptor);\r\n            return () => {\r\n                const index = this.requestInterceptors.indexOf(interceptor);\r\n                if (index > -1) this.requestInterceptors.splice(index, 1);\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Add response interceptor\r\n         */\r\n        public interceptResponse(interceptor: types.Interceptor<types.Response<any>>): () => void {\r\n            this.responseInterceptors.push(interceptor);\r\n            return () => {\r\n                const index = this.responseInterceptors.indexOf(interceptor);\r\n                if (index > -1) this.responseInterceptors.splice(index, 1);\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Make HTTP request\r\n         */\r\n        public async request<T = any>(config: types.RequestConfig): Promise<types.Response<T>> {\r\n            // Merge with default config\r\n            let mergedConfig = { ...this.config, ...config };\r\n\r\n            // Run request interceptors\r\n            for (const interceptor of this.requestInterceptors) {\r\n                if (interceptor.onFulfilled) {\r\n                    mergedConfig = await interceptor.onFulfilled(mergedConfig);\r\n                }\r\n            }\r\n\r\n            try {\r\n                // Check cache\r\n                const cacheKey = this.getCacheKey(mergedConfig);\r\n                const cached = this.cache.get(cacheKey);\r\n\r\n                if (cached && Date.now() - cached.timestamp < (mergedConfig.timeout || 0)) {\r\n                    return cached.data;\r\n                }\r\n\r\n                // Build URL\r\n                const url = this.buildURL(mergedConfig);\r\n\r\n                // Build request\r\n                const request = new Request(url, {\r\n                    method          : mergedConfig.method || 'GET',\r\n                    headers         : new Headers(mergedConfig.headers || {}),\r\n                    body            : mergedConfig.data ? JSON.stringify(mergedConfig.data) : undefined,\r\n                    signal          : mergedConfig.signal,\r\n                    credentials     : mergedConfig.withCredentials ? 'include' : 'same-origin'\r\n                });\r\n\r\n                // Make request\r\n                const fetchResponse = await fetch(request);\r\n\r\n                // Parse response\r\n                let data: T;\r\n                const responseType = mergedConfig.responseType || 'json';\r\n\r\n                switch (responseType) {\r\n                    case 'json':\r\n                        data = await fetchResponse.json();\r\n                        break;\r\n                    case 'text':\r\n                        data = await fetchResponse.text() as any;\r\n                        break;\r\n                    case 'blob':\r\n                        data = await fetchResponse.blob() as any;\r\n                        break;\r\n                    case 'arraybuffer':\r\n                        data = await fetchResponse.arrayBuffer() as any;\r\n                        break;\r\n                    default:\r\n                        data = await fetchResponse.json();\r\n                }\r\n\r\n                // Build response\r\n                let response: types.Response<T> = {\r\n                    data,\r\n                    status      : fetchResponse.status,\r\n                    statusText  : fetchResponse.statusText,\r\n                    headers     : fetchResponse.headers,\r\n                    config      : mergedConfig\r\n                };\r\n\r\n                // Check status\r\n                if (!fetchResponse.ok) {\r\n                    throw this.createError(\r\n                        `Request failed with status ${fetchResponse.status}`,\r\n                        mergedConfig,\r\n                        response\r\n                    );\r\n                }\r\n\r\n                // Run response interceptors\r\n                for (const interceptor of this.responseInterceptors) {\r\n                    if (interceptor.onFulfilled) {\r\n                        response = await interceptor.onFulfilled(response);\r\n                    }\r\n                }\r\n\r\n                // Cache response\r\n                this.cache.set(cacheKey, {\r\n                    data        : response,\r\n                    timestamp   : Date.now()\r\n                });\r\n\r\n                return response;\r\n\r\n            } catch (error: any) {\r\n                // Run error interceptors\r\n                let finalError = error;\r\n\r\n                for (const interceptor of this.responseInterceptors) {\r\n                    if (interceptor.onRejected) {\r\n                        finalError = await interceptor.onRejected(finalError);\r\n                    }\r\n                }\r\n\r\n                throw finalError;\r\n            }\r\n        }\r\n\r\n        private buildURL(config: types.RequestConfig): string {\r\n            let url = config.url;\r\n\r\n            // Add base URL\r\n            if (config.baseURL) {\r\n                url = config.baseURL + url;\r\n            }\r\n\r\n            // Add params\r\n            if (config.params) {\r\n                const params = new URLSearchParams();\r\n                Object.entries(config.params).forEach(([key, value]) => {\r\n                    if (value != null) {\r\n                        params.append(key, String(value));\r\n                    }\r\n                });\r\n\r\n                const query = params.toString();\r\n                if (query) {\r\n                    url += (url.includes('?') ? '&' : '?') + query;\r\n                }\r\n            }\r\n\r\n            return url;\r\n        }\r\n\r\n        private getCacheKey(config: types.RequestConfig): string {\r\n            return `${config.method || 'GET'}:${config.url}:${JSON.stringify(config.params || {})}`;\r\n        }\r\n\r\n        private createError(\r\n            message: string,\r\n            config: types.RequestConfig,\r\n            response?: types.Response<any>\r\n        ): types.HttpError {\r\n            const error     = new Error(message) as types.HttpError;\r\n            error.config    = config;\r\n            error.response  = response;\r\n            error.status    = response?.status;\r\n            return error;\r\n        }\r\n\r\n        // ============================================================================\r\n        // CONVENIENCE METHODS\r\n        // ============================================================================\r\n\r\n        public get<T = any>(url: string, config?: Partial<types.RequestConfig>): Promise<types.Response<T>> {\r\n            return this.request<T>({ ...config, url, method: 'GET' });\r\n        }\r\n\r\n        public post<T = any>(url: string, data?: any, config?: Partial<types.RequestConfig>): Promise<types.Response<T>> {\r\n            return this.request<T>({ ...config, url, data, method: 'POST' });\r\n        }\r\n\r\n        public put<T = any>(url: string, data?: any, config?: Partial<types.RequestConfig>): Promise<types.Response<T>> {\r\n            return this.request<T>({ ...config, url, data, method: 'PUT' });\r\n        }\r\n\r\n        public patch<T = any>(url: string, data?: any, config?: Partial<types.RequestConfig>): Promise<types.Response<T>> {\r\n            return this.request<T>({ ...config, url, data, method: 'PATCH' });\r\n        }\r\n\r\n        public delete<T = any>(url: string, config?: Partial<types.RequestConfig>): Promise<types.Response<T>> {\r\n            return this.request<T>({ ...config, url, method: 'DELETE' });\r\n        }\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ MAIN ════════════════════════════════════════╗\r\n\r\n    export const http = new HttpClient();\r\n\r\n    /**\r\n     * Configure global HTTP client\r\n     */\r\n    export function configureHttp(config: Partial<types.RequestConfig>): void {\r\n        http.setConfig(config);\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\r\n\r\n    // QUERY HOOK (like React Query / SWR)\r\n    export function useQuery<T = any>(\r\n        queryKey: string | string[],\r\n        queryFn: () => Promise<types.Response<T>>,\r\n        options: Partial<types.QueryOptions<T>> = {}\r\n    ): types.QueryResult<T> {\r\n        const data = signal<T | null>(null);\r\n        const error = signal<types.HttpError | null>(null);\r\n        const isLoading = signal(false);\r\n        const isError = computed(() => error() !== null);\r\n        const isSuccess = computed(() => data() !== null && error() === null);\r\n\r\n        const enabled = typeof options.enabled === 'function'\r\n            ? options.enabled\r\n            : signal(options.enabled !== false);\r\n\r\n        const fetchData = async () => {\r\n            if (!enabled()) return;\r\n\r\n            isLoading.set(true);\r\n            error.set(null);\r\n\r\n            try {\r\n                const response = await queryFn();\r\n                data.set(response.data);\r\n                options.onSuccess?.(response.data);\r\n            } catch (err) {\r\n                const httpError = err as types.HttpError;\r\n                error.set(httpError);\r\n                options.onError?.(httpError);\r\n            } finally {\r\n                isLoading.set(false);\r\n            }\r\n        };\r\n\r\n        // Initial fetch\r\n        effect(() => {\r\n            if (enabled()) {\r\n                fetchData();\r\n            }\r\n        });\r\n\r\n        // Refetch on window focus\r\n        if (options.refetchOnWindowFocus) {\r\n            window.addEventListener('focus', fetchData);\r\n        }\r\n\r\n        // Refetch interval\r\n        if (options.refetchInterval) {\r\n            setInterval(fetchData, options.refetchInterval);\r\n        }\r\n\r\n        return {\r\n            data,\r\n            error,\r\n            isLoading,\r\n            isError,\r\n            isSuccess,\r\n            refetch: fetchData\r\n        };\r\n    }\r\n\r\n    // MUTATION HOOK\r\n    export function useMutation<T = any, V = any>(\r\n        mutationFn: (variables: V) => Promise<types.Response<T>>,\r\n        options: types.MutationOptions<T, V> = {}\r\n    ): types.MutationResult<T, V> {\r\n        const data = signal<T | null>(null);\r\n        const error = signal<types.HttpError | null>(null);\r\n        const isLoading = signal(false);\r\n\r\n        const mutate = async (variables: V): Promise<T> => {\r\n            isLoading.set(true);\r\n            error.set(null);\r\n\r\n            options.onMutate?.(variables);\r\n\r\n            try {\r\n                const response = await mutationFn(variables);\r\n                data.set(response.data);\r\n                options.onSuccess?.(response.data, variables);\r\n                return response.data;\r\n            } catch (err) {\r\n                const httpError = err as types.HttpError;\r\n                error.set(httpError);\r\n                options.onError?.(httpError, variables);\r\n                throw httpError;\r\n            } finally {\r\n                isLoading.set(false);\r\n            }\r\n        };\r\n\r\n        const reset = () => {\r\n            data.set(null);\r\n            error.set(null);\r\n            isLoading.set(false);\r\n        };\r\n\r\n        return {\r\n            data,\r\n            error,\r\n            isLoading,\r\n            mutate,\r\n            reset\r\n        };\r\n    }\r\n\r\n    // RETRY UTILITY\r\n    export async function retry<T>(\r\n        fn: () => Promise<T>,\r\n        config: types.RetryConfig = {}\r\n    ): Promise<T> {\r\n        const {\r\n            retries = 3,\r\n            retryDelay = (attempt) => Math.min(1000 * 2 ** attempt, 30000),\r\n            retryCondition = () => true\r\n        } = config;\r\n\r\n        let lastError: any;\r\n\r\n        for (let attempt = 0; attempt <= retries; attempt++) {\r\n            try {\r\n                return await fn();\r\n            } catch (error) {\r\n                lastError = error;\r\n\r\n                if (attempt < retries && retryCondition(error as types.HttpError)) {\r\n                    const delay = typeof retryDelay === 'function'\r\n                        ? retryDelay(attempt)\r\n                        : retryDelay;\r\n\r\n                    await new Promise(resolve => setTimeout(resolve, delay));\r\n                } else {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n\r\n        throw lastError;\r\n    }\r\n\r\n    // ABORT CONTROLLER UTILITY\r\n    export function createAbortController(timeout?: number): AbortController {\r\n        const controller = new AbortController();\r\n\r\n        if (timeout) {\r\n            setTimeout(() => controller.abort(), timeout);\r\n        }\r\n\r\n        return controller;\r\n    }\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\r\n\r\n\r\n\r\n// ╔════════════════════════════════════════ CORE ════════════════════════════════════════╗\r\n\r\n    export default {\r\n        HttpClient,\r\n        http,\r\n        configureHttp,\r\n        useQuery,\r\n        useMutation,\r\n        retry,\r\n        createAbortController\r\n    };\r\n\r\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"]}