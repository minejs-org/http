import {signal,computed,effect}from'@minejs/signals';var f=class{constructor(t={}){this.config={};this.requestInterceptors=[];this.responseInterceptors=[];this.cache=new Map;this.config=t;}setConfig(t){this.config={...this.config,...t};}interceptRequest(t){return this.requestInterceptors.push(t),()=>{let e=this.requestInterceptors.indexOf(t);e>-1&&this.requestInterceptors.splice(e,1);}}interceptResponse(t){return this.responseInterceptors.push(t),()=>{let e=this.responseInterceptors.indexOf(t);e>-1&&this.responseInterceptors.splice(e,1);}}async request(t){let e={...this.config,...t};for(let s of this.requestInterceptors)s.onFulfilled&&(e=await s.onFulfilled(e));try{let s=this.getCacheKey(e),r=this.cache.get(s);if(r&&Date.now()-r.timestamp<(e.timeout||0))return r.data;let a=this.buildURL(e),i=new Request(a,{method:e.method||"GET",headers:new Headers(e.headers||{}),body:e.data?JSON.stringify(e.data):void 0,signal:e.signal,credentials:e.withCredentials?"include":"same-origin"}),n=await fetch(i),o;switch(e.responseType||"json"){case "json":o=await n.json();break;case "text":o=await n.text();break;case "blob":o=await n.blob();break;case "arraybuffer":o=await n.arrayBuffer();break;default:o=await n.json();}let c={data:o,status:n.status,statusText:n.statusText,headers:n.headers,config:e};if(!n.ok)throw this.createError(`Request failed with status ${n.status}`,e,c);for(let y of this.responseInterceptors)y.onFulfilled&&(c=await y.onFulfilled(c));return this.cache.set(s,{data:c,timestamp:Date.now()}),c}catch(s){let r=s;for(let a of this.responseInterceptors)a.onRejected&&(r=await a.onRejected(r));throw r}}buildURL(t){let e=t.url;if(t.baseURL&&(e=t.baseURL+e),t.params){let s=new URLSearchParams;Object.entries(t.params).forEach(([a,i])=>{i!=null&&s.append(a,String(i));});let r=s.toString();r&&(e+=(e.includes("?")?"&":"?")+r);}return e}getCacheKey(t){return `${t.method||"GET"}:${t.url}:${JSON.stringify(t.params||{})}`}createError(t,e,s){let r=new Error(t);return r.config=e,r.response=s,r.status=s?.status,r}get(t,e){return this.request({...e,url:t,method:"GET"})}post(t,e,s){return this.request({...s,url:t,data:e,method:"POST"})}put(t,e,s){return this.request({...s,url:t,data:e,method:"PUT"})}patch(t,e,s){return this.request({...s,url:t,data:e,method:"PATCH"})}delete(t,e){return this.request({...e,url:t,method:"DELETE"})}},d=new f;function T(u){d.setConfig(u);}function m(u,t,e={}){let s=signal(null),r=signal(null),a=signal(false),i=computed(()=>r()!==null),n=computed(()=>s()!==null&&r()===null),o=typeof e.enabled=="function"?e.enabled:signal(e.enabled!==false),p=async()=>{if(o()){a.set(true),r.set(null);try{let c=await t();s.set(c.data),e.onSuccess?.(c.data);}catch(c){let y=c;r.set(y),e.onError?.(y);}finally{a.set(false);}}};return effect(()=>{o()&&p();}),e.refetchOnWindowFocus&&window.addEventListener("focus",p),e.refetchInterval&&setInterval(p,e.refetchInterval),{data:s,error:r,isLoading:a,isError:i,isSuccess:n,refetch:p}}function R(u,t={}){let e=signal(null),s=signal(null),r=signal(false);return {data:e,error:s,isLoading:r,mutate:async n=>{r.set(true),s.set(null),t.onMutate?.(n);try{let o=await u(n);return e.set(o.data),t.onSuccess?.(o.data,n),o.data}catch(o){let p=o;throw s.set(p),t.onError?.(p,n),p}finally{r.set(false);}},reset:()=>{e.set(null),s.set(null),r.set(false);}}}async function w(u,t={}){let{retries:e=3,retryDelay:s=i=>Math.min(1e3*2**i,3e4),retryCondition:r=()=>true}=t,a;for(let i=0;i<=e;i++)try{return await u()}catch(n){if(a=n,i<e&&r(n)){let o=typeof s=="function"?s(i):s;await new Promise(p=>setTimeout(p,o));}else throw n}throw a}function b(u){let t=new AbortController;return u&&setTimeout(()=>t.abort(),u),t}var C={HttpClient:f,http:d,configureHttp:T,useQuery:m,useMutation:R,retry:w,createAbortController:b};export{f as HttpClient,T as configureHttp,b as createAbortController,C as default,d as http,w as retry,R as useMutation,m as useQuery};//# sourceMappingURL=main.js.map
//# sourceMappingURL=main.js.map